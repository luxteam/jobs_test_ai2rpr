

/*

Arnold to RadeonProRender Converter

History:
v.1.0 - first version
v.1.1 - aiStandartSurface support
v.1.2 - displacement, bump2d conversion
v.1.3 - aiSkyDomeLight and aiAreaLight support
v.1.4 - Opacity reverse node, rotate IBL and aiPhysicalSky support
v.1.5 - aiPhotometricLight support.
v.1.6 - Fix ies light position; aiStandartVolume, aiMixShader, aiFlat, aiSky, aiAdd, aiSubstract, aiDivide, aiMultiply support
v.1.7 - Fix bug with channel converting, fix bug with creating extra materials.

*/


global proc write_converted_property_log(string $rprMaterial, string $aiMaterial, string $attrRPR, string $attrAI) { 

    $filePath = `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"`;  
    fprint $fileId ("    property " + $aiMaterial + "." + $attrAI + " converted to " + $rprMaterial + "." + $attrRPR + "   \r\n"); 
    fclose $fileId;   
} 

global proc write_own_property_log(string $text) { 

    $filePath = `file -q -sceneName` + ".log";;  
    $fileId = `fopen $filePath "a"`;  
    fprint $fileId ("    " + $text + "   \r\n"); 
    fclose $fileId;   
} 

// dispalcement convertion
global proc convertDisplacement(string $ai_sg, string $rpr) {

    string $displacement[] = `listConnections -type displacementShader $ai_sg`;
    if (size($displacement)) {
        string $fileDisplacement[] = `listConnections -type file $displacement[0]`; 
        if (size($fileDisplacement)) {
            setAttr ($rpr + ".displacementEnable") 1;
            catchQuiet (`connectAttr -f ($fileDisplacement[0] + ".outColor") ($rpr + ".displacementMap")`);
            copyProperty($rpr, $displacement[0], "scale", "displacementMax");
            write_converted_property_log($rpr , $fileDisplacement[0], "outColor", "displacementMap");
            write_converted_property_log($rpr , $displacement[0], "scale", "displacementMax");
        }
    }

}

global proc string convertaiAdd(string $ai, string $source) {
    
    string $rpr;

    if( `objExists ($ai + "_rpr")` ) {

        $rpr = $ai + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRArithmetic`;
        rename $rpr ($ai + "_rpr"); 
        $rpr = $ai + "_rpr";

        // Logging in file 
        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        string $type = `objectType $ai`;
        string $typeRPR = `objectType $rpr`;
        fprint $fileId ("    Found Arnold Ambient Occlusion: \r\n    name: " + $ai + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        setAttr ($rpr + ".operation") 0;
        copyPropertyColor($rpr, $ai, "input1", "inputA");
        copyPropertyColor($rpr, $ai, "input2", "inputB");

        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $ai); 
        fprint $fileId ("\r\n");   
        fclose $fileId;  

    }

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outX"; break;
        case "outColorG": $source = "outY"; break;
        case "outColorB": $source = "outZ"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}

global proc string convertaiDivide(string $ai, string $source) {
    
    string $rpr;

    if( `objExists ($ai + "_rpr")` ) {

        $rpr = $ai + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRArithmetic`;
        rename $rpr ($ai + "_rpr"); 
        $rpr = $ai + "_rpr";

        // Logging in file 
        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        string $type = `objectType $ai`;
        string $typeRPR = `objectType $rpr`;
        fprint $fileId ("    Found Redshift Ambient Occlusion: \r\n    name: " + $ai + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        setAttr ($rpr + ".operation") 3;
        copyPropertyColor($rpr, $ai, "input1", "inputA");
        copyPropertyColor($rpr, $ai, "input2", "inputB");

        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $ai); 
        fprint $fileId ("\r\n");   
        fclose $fileId;

    }  

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outX"; break;
        case "outColorG": $source = "outY"; break;
        case "outColorB": $source = "outZ"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}

global proc string convertaiSubstract(string $ai, string $source) {
    
    string $rpr;

    if( `objExists ($ai + "_rpr")` ) {

        $rpr = $ai + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRArithmetic`;
        rename $rpr ($ai + "_rpr"); 
        $rpr = $ai + "_rpr";

        // Logging in file 
        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        string $type = `objectType $ai`;
        string $typeRPR = `objectType $rpr`;
        fprint $fileId ("    Found Redshift Ambient Occlusion: \r\n    name: " + $ai + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        setAttr ($rpr + ".operation") 1;
        copyPropertyColor($rpr, $ai, "input1", "inputA");
        copyPropertyColor($rpr, $ai, "input2", "inputB");

        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $ai); 
        fprint $fileId ("\r\n");   
        fclose $fileId;

    }

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outX"; break;
        case "outColorG": $source = "outY"; break;
        case "outColorB": $source = "outZ"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}

global proc string convertaiMultiply(string $ai, string $source) {
    
    string $rpr;

    if( `objExists ($ai + "_rpr")` ) {

        $rpr = $ai + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRArithmetic`;
        rename $rpr ($ai + "_rpr"); 
        $rpr = $ai + "_rpr";

        // Logging in file 
        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        string $type = `objectType $ai`;
        string $typeRPR = `objectType $rpr`;
        fprint $fileId ("    Found Redshift Ambient Occlusion: \r\n    name: " + $ai + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        setAttr ($rpr + ".operation") 2;
        copyPropertyColor($rpr, $ai, "input1", "inputA");
        copyPropertyColor($rpr, $ai, "input2", "inputB");

        $filePath =  `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $ai); 
        fprint $fileId ("\r\n");   
        fclose $fileId;  

    }

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outX"; break;
        case "outColorG": $source = "outY"; break;
        case "outColorB": $source = "outZ"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}

global proc string convertbump2d(string $ai, string $source) {
    
    string $rpr;

    if( `objExists ($ai + "_rpr")` ) {

        $rpr = $ai + "_rpr";

    } else {

        $bumpType = `getAttr ($ai + ".bumpInterp")`;

        if ($bumpType == 0) {
            $rpr = `shadingNode -asUtility RPRBump`;
            rename $rpr ($ai + "_rpr"); 
            $rpr = $ai + "_rpr";
        } else {
            $rpr = `shadingNode -asUtility RPRNormal`;
            rename $rpr ($ai + "_rpr"); 
            $rpr = $ai + "_rpr";
        }

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        string $type = `objectType $ai`;
        string $typeRPR = `objectType $rpr`;
        fprint $fileId ("    Found Redshift Fresnel: \r\n    name: " + $ai + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        string $bump2dConnections[] = `listConnections -type file ($ai + ".bumpValue")`; 
        if (size($bump2dConnections)) {
            connectAttr -f ($bump2dConnections[0] + ".outColor") ($rpr + ".color");
        }

        copyProperty($rpr, $ai, "bumpDepth", "strength");

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $ai); 
        fprint $fileId ("\r\n");   
        fclose $fileId;  

    }

    switch ($source) {
        case "outNormal": $source = "out"; break;
        case "outNormalX": $source = "outR"; break;
        case "outNormalY": $source = "outG"; break;
        case "outNormalZ": $source = "outB"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}

global proc copyProperty(string $rprMaterial, string $aiMaterial, string $attrAI, string $attrRPR) { 

    // full name of attribute
    string $tempAI = $aiMaterial + "." + $attrAI; 
    string $tempRPR = $rprMaterial + "." + $attrRPR;

    // check connections
    string $listConnections[] = `listConnections $tempAI`;
    string $source;

    if (size($listConnections)>0) {
        $source = `connectionInfo -sourceFromDestination $tempAI`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = convertaiMaterial($source_splited[0], $source_splited[1]);
        if ($source == "") {
            $source = `connectionInfo -sourceFromDestination $tempAI`;
        }
    }

    if (size($listConnections)>0) {   
        if (catch(`connectAttr -force $source $tempRPR`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rprMaterial, $aiMaterial, $attrRPR, $source);  
        }  
    } else {
        $varAI = `getAttr $tempAI`; 
        if (catch(`setAttr $tempRPR $varAI`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rprMaterial, $aiMaterial, $attrRPR, $attrAI);  
        }   
    }
} 

global proc copyPropertyColor(string $rprMaterial, string $aiMaterial, string $attrAI, string $attrRPR) { 

    // full name of attribute
    string $tempAI = $aiMaterial + "." + $attrAI; 
    string $tempRPR = $rprMaterial + "." + $attrRPR;

    // check connections
    string $listConnections[] = `listConnections $tempAI`;
    string $source;

    if (size($listConnections)>0) {
        $source = `connectionInfo -sourceFromDestination $tempAI`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = convertaiMaterial($source_splited[0], $source_splited[1]);
        if ($source == "") {
            $source = `connectionInfo -sourceFromDestination $tempAI`;
        }
    }

    if (size($listConnections)>0) {   
        if (catch(`connectAttr -force $source ($rprMaterial + "." + $attrRPR)`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rprMaterial, $aiMaterial, $attrRPR, $source);  
        }  
    } else {
        $varAI_R = `getAttr ($tempAI + "R")`;
        $varAI_G = `getAttr ($tempAI + "G")`;
        $varAI_B = `getAttr ($tempAI + "B")`; 
        if (catch(`setAttr $tempRPR $varAI_R $varAI_G $varAI_B`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rprMaterial, $aiMaterial, $attrRPR, $attrAI); 
        }   
    }
} 

/////////////////////// 
// aiAmbientOcclusion 
/////////////////////// 

global proc string convertaiAmbientOcclusion (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath = `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr; 

}

/////////////////////// 
// aiFlat 
/////////////////////// 

global proc string convertaiFlat (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Flat material
        string $rprMaterialType = "RPRFlatColorMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        copyPropertyColor($rpr, $aiMaterial, "color", "color");

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiMixShader 
/////////////////////// 

global proc string convertaiMixShader (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRBlendMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        copyPropertyColor($rpr, $aiMaterial, "shader1", "color0");
        copyPropertyColor($rpr, $aiMaterial, "shader2", "color1");
        copyProperty($rpr, $aiMaterial, "mix", "weight");

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiRaySwitch 
/////////////////////// 

global proc string convertaiRaySwitch (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId;

    } 

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiShadowMatte 
/////////////////////// 

global proc string convertaiShadowMatte (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiStandardHair 
/////////////////////// 

global proc string convertaiStandardHair (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiStandardSurface 
/////////////////////// 

global proc string convertaiStandardSurface (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

            convertDisplacement($materialSG[0], $rpr);
        }

        // Enable properties, which are default in Arnold
        defaultEnable($rpr, $aiMaterial, "diffuse", "base");
        defaultEnable($rpr, $aiMaterial, "reflections", "specular");
        defaultEnable($rpr, $aiMaterial, "refraction", "transmission");
        defaultEnable($rpr, $aiMaterial, "sssEnable", "subsurface");
        defaultEnable($rpr, $aiMaterial, "separateBackscatterColor", "subsurface");
        defaultEnable($rpr, $aiMaterial, "clearCoat", "coat");
        defaultEnable($rpr, $aiMaterial, "emissive", "emission");

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        copyPropertyColor($rpr, $aiMaterial, "baseColor", "diffuseColor");
        copyProperty($rpr, $aiMaterial, "base", "diffuseWeight");
        copyProperty($rpr, $aiMaterial, "diffuseRoughness", "diffuseRoughness");
        $metalValue = `getAttr ($aiMaterial + ".metalness")`;
        if ($metalValue > 0) {
            setAttr ($rpr + ".reflections") 1;
            setAttr ($rpr + ".reflectMetalMaterial") 1;
            copyProperty($rpr, $aiMaterial, "metalness", "reflectMetalness");
        }

        copyPropertyColor($rpr, $aiMaterial, "specularColor", "reflectColor");
        copyProperty($rpr, $aiMaterial, "specular", "reflectWeight");
        copyProperty($rpr, $aiMaterial, "specularRoughness", "reflectRoughness");
        copyProperty($rpr, $aiMaterial, "specularAnisotropy", "reflectAnisotropy");
        copyProperty($rpr, $aiMaterial, "specularRotation", "reflectAnisotropyRotation");
        copyProperty($rpr, $aiMaterial, "specularIOR", "reflectIOR");

        copyPropertyColor($rpr, $aiMaterial, "transmissionColor", "refractColor");
        copyProperty($rpr, $aiMaterial, "transmission", "refractWeight");
        copyProperty($rpr, $aiMaterial, "transmissionExtraRoughness", "refractRoughness");
        $thinValue = `getAttr ($aiMaterial + ".thinWalled")`;
        setAttr ($rpr + ".refractThinSurface") $thinValue;

        copyPropertyColor($rpr, $aiMaterial, "subsurfaceColor", "volumeScatter");
        copyProperty($rpr, $aiMaterial, "subsurface", "sssWeight");
        copyProperty($rpr, $aiMaterial, "subsurface", "backscatteringWeight");
        copyPropertyColor($rpr, $aiMaterial, "subsurfaceRadius", "subsurfaceRadius");

        copyPropertyColor($rpr, $aiMaterial, "coatColor", "coatColor");
        copyProperty($rpr, $aiMaterial, "coat", "coatWeight");
        copyProperty($rpr, $aiMaterial, "coatRoughness", "coatRoughness");
        copyProperty($rpr, $aiMaterial, "coatIOR", "coatIor");

        $coatNormalAI_X = `getAttr ($aiMaterial + ".coatNormalX")`;
        $coatNormalAI_Y = `getAttr ($aiMaterial + ".coatNormalY")`;
        $coatNormalAI_Z = `getAttr ($aiMaterial + ".coatNormalZ")`; 

        string $listConnections[] = `listConnections ($aiMaterial + ".coatNormal")`;
        string $source = "";

        if (size($listConnections)>0) {
            $source = convertaiMaterial($listConnections[0], "");
            if ($source == "") {
                $source = `connectionInfo -sourceFromDestination ($aiMaterial + ".coatNormal")`;
            }
        }

        if (size($listConnections)>0) {   
            if (catch(`connectAttr -force $source ($rpr + ".coatNormal")`)) { 
                write_own_property_log("Connection failed. Check the connectors. ");
            } else { 
                write_converted_property_log($rpr, $aiMaterial, "coatNormal", $source);  
            }  
        } else {
            if (catch(`setAttr ($rpr + ".coatNormal") $coatNormalAI_X $coatNormalAI_Y $coatNormalAI_Z`)) { 
                write_own_property_log("Copy failed. Check the values and their boundaries. ");
            } else { 
                write_converted_property_log($rpr, $aiMaterial, "coatNormal", "coatNormal"); 
            }   
        }

        copyPropertyColor($rpr, $aiMaterial, "emissionColor", "emissiveColor");
        copyProperty($rpr, $aiMaterial, "emission", "emissiveWeight");

        // Opacity convert
        $opacityAI_R_t = `getAttr ($aiMaterial+".opacityR")`;
        $opacityAI_G_t = `getAttr ($aiMaterial+".opacityG")`;
        $opacityAI_B_t = `getAttr ($aiMaterial+".opacityB")`; 

        string $opacityConnections[] = `listConnections ($aiMaterial+".opacity")`;

        if (size($opacityConnections)>0) {   
            string $reverse = `shadingNode -asUtility reverse`; 
            connectAttr -force ($reverse + ".message") ($rpr + ".transparencyLevel");
            string $source = `connectionInfo -sourceFromDestination ($aiMaterial+".opacity")`;
            if (catch(`connectAttr -force $source ($reverse + ".input")`)) { 
                write_own_property_log("Connection failed. Check the connectors. ");
            } else { 
                setAttr ($rpr + ".transparencyEnable") 1;
                write_converted_property_log($rpr, $aiMaterial, "transparencyLevel", $source);  
            }  
        } else {
            float $opacityAI_R = $opacityAI_R_t;
            float $opacityAI_G = $opacityAI_G_t;
            float $opacityAI_B = $opacityAI_B_t;
            float $max_value = `max $opacityAI_R $opacityAI_G`;
            $max_value = `max $max_value $opacityAI_B`;
            $max_value = 1 - $max_value;
            if (catch(`setAttr ($rpr + ".transparencyLevel") $max_value`)) { 
                write_own_property_log("Copy failed. Check the values and their boundaries. ");
            } else { 
                setAttr ($rpr + ".transparencyEnable") 1;
                write_converted_property_log($rpr, $aiMaterial, "transparencyLevel", "opacity_color");  
            }   
        }

        string $bumpConnections[] = `listConnections -type bump2d ($aiMaterial + ".normalCamera")`;
        if (size($bumpConnections)){
            string $source[];
            $source = `connectionInfo -sourceFromDestination ($aiMaterial + ".normalCamera")`;
            string $rpr_bump = convertbump2d($bumpConnections[0], $source[0]);
            setAttr ($rpr + ".normalMapEnable") 1;
            connectAttr -force $rpr_bump ($rpr + ".normalMap");
        }
        

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiSwitch 
/////////////////////// 

global proc string convertaiSwitch (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiTwoSided 
/////////////////////// 

global proc string convertaiTwoSided (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiWireframe 
/////////////////////// 

global proc string convertaiWireframe (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

/////////////////////// 
// aiUtility 
/////////////////////// 

global proc string convertaiUtility (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRUberMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        // 
        //

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}


/////////////////////// 
// aiStandardVolume
/////////////////////// 

global proc string convertaiStandardVolume (string $aiMaterial, string $source) { 

    string $rpr;
    string $materialSG[];

    if( `objExists ($aiMaterial + "_rpr")` ) {

        $rpr = $aiMaterial + "_rpr";

    } else {

        // Creating new Uber material
        string $rprMaterialType = "RPRVolumeMaterial"; 
        $rpr = `shadingNode -asShader $rprMaterialType`; 
        rename $rpr ($aiMaterial + "_rpr");
        $rpr = $aiMaterial + "_rpr"; 

        // Check shading engine in aiMaterial
        $materialSG = `listConnections -type shadingEngine $aiMaterial`;
        string $sg;

        if (size($materialSG)) {

            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

        }

        // Enable properties, which are default in Arnold
        //
        //

        string $type = `objectType $aiMaterial`; 

        // Logging in file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ;
        fprint $fileId ("Found Arnold material: \r\n    name: " + $aiMaterial + "\r\n"); 
        fprint $fileId ("    type: " + $type + "\r\n"); 
        fprint $fileId ("    shading engine: " + $materialSG[0] + "\r\n");
        fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + $rprMaterialType + "\r\n"); 
        fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
        fprint $fileId ("Conversion details: \r\n");  
        fclose $fileId;  

        // Fields convert
        copyPropertyColor($rpr, $aiMaterial, "scatterColor", "scatterColor");
        copyPropertyColor($rpr, $aiMaterial, "emissionColor", "emissionColor");
        copyPropertyColor($rpr, $aiMaterial, "transparent", "transmissionColor");
        copyProperty($rpr, $aiMaterial, "density", "density");

        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("End: " + $aiMaterial);  
        fprint $fileId ("\r\n\r\n\r\n");  
        fclose $fileId; 

    }

    if (!size($materialSG)) {
        $rpr += "." + $source;
    }

    return $rpr;  

}

global proc convertaiPhotometricLight(string $ai_light) {

    // Create, name and scale physical light
    string $iesNode = `createNode RPRIES -n RPRIESLight`;
    string $parent[] = `listRelatives -p $iesNode`;
    string $ai_parent[] = `listRelatives -p $ai_light`;

    string $ai_temp[];
    $numTokens = `tokenize $ai_light "|" $ai_temp`;
    rename $iesNode ($ai_temp[1] + "_rpr");
    $iesNode = $ai_temp[1] + "_rpr";
    rename $parent[0] ($ai_parent[0] + "_rpr");
    $parent[0] = $ai_parent[0] + "_rpr";

    // Logging in file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $ai_light`;
    string $typeRPR = `objectType $iesNode`;
    fprint $fileId ("Found Arnold Light: \r\n    name: " + $ai_light + "\r\n"); 
    fprint $fileId ("    type: " + $type + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $iesNode + "\r\n"); 
    fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties 
    $aiFile = `getAttr ($ai_light + ".aiFilename")`;
    if ($aiFile != ""){
        setAttr -type "string" ($iesNode + ".iesFile") $aiFile;
    }

    $intensity = `getAttr ($ai_light + ".intensity")`;
    $exposure = `getAttr ($ai_light + ".exposure")`;
    $intensity = ($intensity * ($exposure + 5)) / 500;
    setAttr ($iesNode + ".intensity") $intensity;

    copyPropertyColor($iesNode, $ai_light, "color", "color");
    copyProperty($parent[0], $ai_parent[0], "translateX", "translateX");
    copyProperty($parent[0], $ai_parent[0], "translateY", "translateY");
    copyProperty($parent[0], $ai_parent[0], "translateZ", "translateZ");
    setAttr (($parent[0] + ".rotateX"), getAttr($ai_parent[0] + ".rotateX") + 90);
    copyProperty($parent[0], $ai_parent[0], "rotateY", "rotateY");
    copyProperty($parent[0], $ai_parent[0], "rotateZ", "rotateZ");
    copyProperty($parent[0], $ai_parent[0], "scaleX", "scaleX");
    copyProperty($parent[0], $ai_parent[0], "scaleY", "scaleY");
    copyProperty($parent[0], $ai_parent[0], "scaleZ", "scaleZ");

    write_converted_property_log($iesNode, $ai_light, "intensity", "lightIntensity");
    write_converted_property_log($iesNode, $ai_light, "color", "colorPicker");
    write_converted_property_log($iesNode, $ai_light, "exposure", "luminousEfficacy");
    write_converted_property_log($parent[0], $ai_parent[0], "translateX", "translateX");
    write_converted_property_log($parent[0], $ai_parent[0], "translateY", "translateY");
    write_converted_property_log($parent[0], $ai_parent[0], "translateZ", "translateZ");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateX", "rotateX");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateY", "rotateY");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateZ", "rotateZ");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleX", "scaleX");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleY", "scaleY");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleZ", "scaleZ");

    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $iesNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertaiAreaLight(string $ai_light) {

    // Create, name and scale physical light
    string $physicalNode = `createNode RPRPhysicalLight -n RPRPhysicalLightShape`;
    string $parent[] = `listRelatives -p $physicalNode`;
    string $ai_parent[] = `listRelatives -p $ai_light`;

    string $ai_temp[];
    $numTokens = `tokenize $ai_light "|" $ai_temp`;
    rename $physicalNode ($ai_temp[1] + "_rpr");
    $physicalNode = $ai_temp[1] + "_rpr";
    rename $parent[0] ($ai_parent[0] + "_rpr");
    $parent[0] = $ai_parent[0] + "_rpr";

    // Logging in file 
    $filePath = `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $ai_light`;
    string $typeRPR = `objectType $physicalNode`;
    fprint $fileId ("Found Arnold Light: \r\n    name: " + $ai_light + "\r\n"); 
    fprint $fileId ("    type: " + $type + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $physicalNode + "\r\n"); 
    fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties 

    copyProperty($physicalNode, $ai_light, "intensity", "lightIntensity");
    copyPropertyColor($physicalNode, $ai_light, "color", "colorPicker");
    copyProperty($physicalNode, $ai_light, "exposure", "luminousEfficacy");
    copyProperty($parent[0], $ai_parent[0], "translateX", "translateX");
    copyProperty($parent[0], $ai_parent[0], "translateY", "translateY");
    copyProperty($parent[0], $ai_parent[0], "translateZ", "translateZ");
    copyProperty($parent[0], $ai_parent[0], "rotateX", "rotateX");
    copyProperty($parent[0], $ai_parent[0], "rotateY", "rotateY");
    copyProperty($parent[0], $ai_parent[0], "rotateZ", "rotateZ");
    copyProperty($parent[0], $ai_parent[0], "scaleX", "scaleX");
    copyProperty($parent[0], $ai_parent[0], "scaleY", "scaleY");
    copyProperty($parent[0], $ai_parent[0], "scaleZ", "scaleZ");

    write_converted_property_log($physicalNode, $ai_light, "intensity", "lightIntensity");
    write_converted_property_log($physicalNode, $ai_light, "color", "colorPicker");
    write_converted_property_log($physicalNode, $ai_light, "exposure", "luminousEfficacy");
    write_converted_property_log($parent[0], $ai_parent[0], "translateX", "translateX");
    write_converted_property_log($parent[0], $ai_parent[0], "translateY", "translateY");
    write_converted_property_log($parent[0], $ai_parent[0], "translateZ", "translateZ");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateX", "rotateX");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateY", "rotateY");
    write_converted_property_log($parent[0], $ai_parent[0], "rotateZ", "rotateZ");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleX", "scaleX");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleY", "scaleY");
    write_converted_property_log($parent[0], $ai_parent[0], "scaleZ", "scaleZ");

    $filePath = `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $physicalNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertaiSkyDomeLight(string $ai_light) {

    string $iblNode;
    string $parent[];

    if( `objExists "RPRIBL"`) {
        $iblNode = "RPRIBLShape";
        $parent = {"RPRIBL"};
    } else {
        // create IBL
        $iblNode = `createNode RPRIBL -n RPRIBLShape`;
        $parent = `listRelatives -p $iblNode`;
        setAttr ($parent[0] + ".scaleX") 1001.25663706144;
        setAttr ($parent[0] + ".scaleY") 1001.25663706144;
        setAttr ($parent[0] + ".scaleZ") 1001.25663706144;
        rename $parent[0] RPRIBL;
    }

    // Logging in file 
    $filePath = `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $ai_light`;
    string $typeRPR = `objectType $iblNode`;
    fprint $fileId ("Found Arnold Light: \r\n    name: " + $ai_light + "\r\n"); 
    fprint $fileId ("    type: " + $type + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $iblNode + "\r\n"); 
    fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties
    copyProperty($iblNode, $ai_light, "intensity", "intensity");
    string $file[] = `listConnections ($ai_light + ".color")`;
    if (size($file[0])) {
        $mapPath = `getAttr ($file[0] + ".fileTextureName")`;
        setAttr -type "string" ($iblNode + ".filePath") $mapPath;
        write_converted_property_log($iblNode, $file[0], "filePath", "fileTextureName");
    }
    
    string $parentAI[] = `listRelatives -p $ai_light`;
    $rotateY = `getAttr ($parentAI[0] + ".rotateY")`;
    $rotateY = $rotateY + 180;
    setAttr ($parent[0] + ".rotateY") $rotateY;

    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $iblNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertaiPhysicalSky(string $sky) {
    
    string $SkyNode;

    if( `objExists "RPRSky"`) {
        $SkyNode = "RPRSkyShape";
    } else {
        // create RPRSky
        $SkyNode = `createNode RPRSky -n RPRSkyShape`; 
    }
  
    // Logging in file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $sky`;
    string $typeRPR = `objectType $SkyNode`;
    fprint $fileId ("Found Arnold Phisycal sky&sun: \r\n    name: " + $sky + "\r\n"); 
    fprint $fileId ("    type: " + $type + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $SkyNode + "\r\n"); 
    fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from aiPhysicalSky
    setAttr (($SkyNode + ".turbidity"), getAttr($sky + ".turbidity"));
    write_converted_property_log($SkyNode, $sky, "turbidity", "turbidity");
    setAttr (($SkyNode + ".intensity"), getAttr($sky + ".intensity"));
    write_converted_property_log($SkyNode, $sky, "intensity", "intensity");
    setAttr (($SkyNode + ".altitude"), getAttr($sky + ".elevation"));
    write_converted_property_log($SkyNode, $sky, "altitude", "elevation");
    setAttr (($SkyNode + ".azimuth"), getAttr($sky + ".azimuth"));
    write_converted_property_log($SkyNode, $sky, "azimuth", "azimuth");
    setAttr (($SkyNode + ".groundColor"), getAttr($sky + ".groundAlbedoR"), getAttr($sky + ".groundAlbedoG"), getAttr($sky + ".groundAlbedoB"));
    write_converted_property_log($SkyNode, $sky, "groundColor", "groundAlbedo");
    setAttr (($SkyNode + ".sunDiskSize"), getAttr($sky + ".sunSize"));
    write_converted_property_log($SkyNode, $sky, "sunDiskSize", "sunSize");

    $filePath =    `file -q -sceneName` + ".log";  
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $SkyNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  
}

global proc convertaiSky(string $sky) {
    
    string $iblNode;
    string $parent[];

    if( `objExists "RPRIBL"`) {
        $iblNode = "RPRIBLShape";
        $parent = {"RPRIBL"};
    } else {
        // create IBL
        $iblNode = `createNode RPRIBL -n RPRIBLShape`;
        $parent = `listRelatives -p $iblNode`;
        setAttr ($parent[0] + ".scaleX") 1001.25663706144;
        setAttr ($parent[0] + ".scaleY") 1001.25663706144;
        setAttr ($parent[0] + ".scaleZ") 1001.25663706144;
        rename $parent[0] RPRIBL;
    }
  
    // Logging in file 
    $filePath = `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $sky`;
    string $typeRPR = `objectType $iblNode`;
    fprint $fileId ("Found Arnold sky: \r\n    name: " + $sky + "\r\n"); 
    fprint $fileId ("    type: " + $type + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $iblNode + "\r\n"); 
    fprint $fileId ("    type: " + $typeRPR + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from aiSky
    setAttr (($iblNode + ".intensity"), getAttr($sky + ".intensity"));
    write_converted_property_log($iblNode, $sky, "intensity", "intensity");

    $filePath = `file -q -sceneName` + ".log";  
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $iblNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  
}

// Convert material. Returns new material name.
global proc string convertaiMaterial (string $aiMaterial, string $source) {
	
    string $type = `objectType $aiMaterial`;
    string $rprMaterial;

	switch ($type) {

        case "aiAmbientOcclusion": $rprMaterial = convertaiAmbientOcclusion($aiMaterial, $source); break;
        case "aiFlat": $rprMaterial = convertaiFlat($aiMaterial, $source); break;
        case "aiMixShader": $rprMaterial = convertaiMixShader($aiMaterial, $source); break;
        case "aiRaySwitch": $rprMaterial = convertaiRaySwitch($aiMaterial, $source); break;
        case "aiShadowMatte": $rprMaterial = convertaiShadowMatte($aiMaterial, $source); break;
        case "aiStandardHair": $rprMaterial = convertaiStandardHair($aiMaterial, $source); break;
        case "aiStandardSurface": $rprMaterial = convertaiStandardSurface($aiMaterial, $source); break;
        case "aiSwitch": $rprMaterial = convertaiSwitch($aiMaterial, $source); break;
        case "aiTwoSided": $rprMaterial = convertaiTwoSided($aiMaterial, $source); break;
        case "aiUtility": $rprMaterial = convertaiUtility($aiMaterial, $source); break;
        case "aiWireframe": $rprMaterial = convertaiWireframe($aiMaterial, $source); break;
        case "aiStandardVolume": $rprMaterial = convertaiStandardVolume($aiMaterial, $source); break;
       
        //utilities
        case "bump2d": $rprMaterial = convertbump2d($aiMaterial, $source); break;
        //case "aiBump2d": $rprMaterial = convertaiBump2d($aiMaterial, $source); break;
        //case "aiBump3d": $rprMaterial = convertaiBump3d($aiMaterial, $source); break;
        case "aiAdd": $rprMaterial = convertaiAdd($aiMaterial, $source); break;
        case "aiMultiply": $rprMaterial = convertaiMultiply($aiMaterial, $source); break;
        case "aiDivide": $rprMaterial = convertaiDivide($aiMaterial, $source); break;
        case "aiSubtract": $rprMaterial = convertaiSubstract($aiMaterial, $source); break;
        
        default : break;

    }

    return $rprMaterial;

}

// Convert light. Returns new light name.
global proc convertLight (string $light) {
    
    string $type = `objectType $light`;

    switch ($type) {

        case "aiAreaLight": convertaiAreaLight($light); break;
        //case "aiMeshLight": convertaiMeshLight($light); break;
        case "aiPhotometricLight": convertaiPhotometricLight($light); break;
        case "aiSkyDomeLight": convertaiSkyDomeLight($light); break;
        default : break;
    }
}

global proc int searchaiType(string $obj) {

    if( `objExists $obj` ) {
        string $objType = `objectType $obj`;
        string $tempStr = substring($objType, 1, 2);
        if ($tempStr == "ai") {
            return 1;
        }
    }
    return 0;
}

global proc cleanScene(){

    // Logging in file 
    $filePath = `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Deleted: \r\n"); 
    fclose $fileId;

    string $shEng[];
    string $listMaterials[] = `ls -materials`;
    for ($material in $listMaterials) { 
        if (searchaiType($material)){
            $shEng = `listConnections -type shadingEngine $material`; 
            write_own_property_log($material);
            catchQuiet (`delete $shEng[0]`);
            catchQuiet (`delete $material`);
        }
    }

    string $listLights[] = `ls -l -type aiAreaLight -type aiMeshLight -type aiPhotometricLight -type aiSkyDomeLight`;
    string $transform[];
    for ($light in $listLights) {
        $transform = `listRelatives -p $light`;
        catchQuiet (`delete $light`);
        catchQuiet (`delete $transform[0]`);
    }

    string $listObjects[] = `ls -l`;
    for ($object in $listObjects) {
        if (searchaiType($object)){
            write_own_property_log($object);
            catchQuiet (`delete $object`);
        }
    }

}

global proc int checkMaterial(string $material){
    
    if (searchaiType($material)) {
        string $SGs[] = `listConnections -type shadingEngine $material`; 
        if (size($SGs[0])) {
            return 1;
        }
    }
    return 0;

}

global proc defaultEnable(string $RPRmaterial, string $aiMaterial, string $enable, string $value){
    
    $weight = `getAttr ($aiMaterial + "." + $value)`;
    if ($weight > 0) {
        setAttr ($RPRmaterial + "." + $enable) 1;
    } else {
        setAttr ($RPRmaterial + "." + $enable) 0;
    }   

}

global proc convertScene(){

    // Check plugins
    if( ! `pluginInfo -q -loaded "mtoa"` )
    {
        loadPlugin "mtoa";
    }
    if( ! `pluginInfo -q -loaded "RadeonProRender"` )
    {
        loadPlugin "RadeonProRender";
    }

    // Convert aiEnvironment
    //string $env[] = `ls -type aiEnvironment`;
    //if ((size($env)>0) && (size($env)<2)) {
    //   catchQuiet (`converaiEnvironment($env[0])`);
    //} 

    // Convert sky system
    string $sky[] = `ls -type aiPhysicalSky -type aiSky`;
    if (size($sky)) {
        string $type = `objectType $sky[0]`;
        switch ($type) {
            case "aiPhysicalSky": convertaiPhysicalSky($sky[0]); break;
            case "aiSky": convertaiSky($sky[0]); break;
        }
    }

    // Convert lights
    string $listLights[] = `ls -l -type aiAreaLight -type aiMeshLight -type aiPhotometricLight -type aiSkyDomeLight`;
    for ($light in $listLights) { 
       catchQuiet (`convertLight($light)`);
    } 

    // Get all materials from scene
    string $listMaterials[] = `ls -materials`;

    // Array of association of Arnold & RPR
    string $aiMaterials[];
    string $rprMaterials[];
    int $i = 0;

    // Convert materials
    for ($each in $listMaterials) { 
        if (checkMaterial($each)) {
            $aiMaterials[$i] = $each;
            $rprMaterials[$i] = convertaiMaterial($each, "");
            $i += 1;
        }
    } 

    for ($k = 0; $k < size($aiMaterials); $k++ ) {
        hyperShade -objects $aiMaterials[$k];
        string $sg[] = `listConnections -type shadingEngine $rprMaterials[$k]`;
        sets -e -forceElement $sg[0];
    }

}

global proc auto_launch(){
    convertScene();
    cleanScene();
}

global proc manual_launch(){
    global int $manual;

    if ($manual == 0){
        string $filePath = "";
        print("Convertion start!");
        float $startTime = 0;
        float $testTime = 0;
        $startTime = `timerX`;
        convertScene();
        $testTime = `timerX -startTime $startTime`;
        print("Convertion finished! Time: " + $testTime);

        $response = `confirmDialog -title "Convertation finished" 
                                  -message ("Total time: " + $testTime + "\nDelete all Arnold instances?")
                                  -button "Yes" 
                                  -button "No"
                                  -defaultButton "Yes"
                                  -cancelButton "No"
                                  -dismissString "No"`;
                
        if( $response == "Yes" ) {
            cleanScene();
        }

        system("load " + `file -q -sceneName` + ".log" );
    }
}

manual_launch();